generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String        @id @default(uuid()) @db.Uuid
  email            String        @unique
  name             String
  avatarUrl        String?       @map("avatar_url")
  plan             String        @default("FREE")
  shelvesVisibleTo String        @default("club") @map("shelves_visible_to")
  createdAt        DateTime      @default(now()) @map("created_at")
  updatedAt        DateTime      @updatedAt @map("updated_at")
  clubs            Club[]        @relation("ClubOwner")
  memberships      Membership[]
  pollOptions      PollOption[]  @relation("PollProposer")
  pollsCreated     Poll[]        @relation("PollCreator")
  rsvps            Rsvp[]
  shelves          Shelf[]
  votes            Vote[]

  @@map("users")
}

model Book {
  id            String        @id @default(uuid()) @db.Uuid
  isbn10        String?       @map("isbn10")
  isbn13        String?       @map("isbn13")
  openlibraryId String?       @map("openlibrary_id")
  title         String
  authors       String[]
  coverUrl      String?       @map("cover_url")
  publishedYear Int?          @map("published_year")
  subjects      String[]
  createdAt     DateTime      @default(now()) @map("created_at")
  updatedAt     DateTime      @updatedAt @map("updated_at")
  meetings      Meeting[]     @relation("MeetingCurrentBook")
  pollOptions   PollOption[]
  readingPlans  ReadingPlan[]
  shelfItems    ShelfItem[]

  @@map("books")
}

model Shelf {
  id         String      @id @default(uuid()) @db.Uuid
  userId     String      @map("user_id") @db.Uuid
  type       ShelfType
  name       String?     // Custom shelf name (required for CUSTOM type, null for predefined types)
  isArchived Boolean     @default(false) @map("is_archived")
  createdAt  DateTime    @default(now()) @map("created_at")
  updatedAt  DateTime    @updatedAt @map("updated_at")
  items      ShelfItem[]
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Custom shelf names must be unique per user (only applies when name is not null)
  @@unique([userId, name])
  @@map("shelves")
}



model ShelfItem {
  id         String    @id @default(uuid()) @db.Uuid
  shelfId    String    @map("shelf_id") @db.Uuid
  bookId     String    @map("book_id") @db.Uuid
  addedAt    DateTime  @default(now()) @map("added_at")
  rating     Int?      @db.SmallInt
  review     String?
  finishedAt DateTime? @map("finished_at")
  book       Book      @relation(fields: [bookId], references: [id])
  shelf      Shelf     @relation(fields: [shelfId], references: [id], onDelete: Cascade)

  @@map("shelf_items")
}

model Club {
  id           String        @id @default(uuid()) @db.Uuid
  ownerId      String        @map("owner_id") @db.Uuid
  name         String
  description  String?
  isPublic     Boolean       @default(false) @map("is_public")
  createdAt    DateTime      @default(now()) @map("created_at")
  updatedAt    DateTime      @updatedAt @map("updated_at")
  owner        User          @relation("ClubOwner", fields: [ownerId], references: [id])
  meetings     Meeting[]
  memberships  Membership[]
  polls        Poll[]
  readingPlans ReadingPlan[]

  @@map("clubs")
}

model Membership {
  id       String       @id @default(uuid()) @db.Uuid
  clubId   String       @map("club_id") @db.Uuid
  userId   String       @map("user_id") @db.Uuid
  role     MemberRole   @default(MEMBER)
  status   MemberStatus @default(ACTIVE)
  joinedAt DateTime     @default(now()) @map("joined_at")
  club     Club         @relation(fields: [clubId], references: [id], onDelete: Cascade)
  user     User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([clubId, userId])
  @@map("memberships")
}

model Meeting {
  id                String        @id @default(uuid()) @db.Uuid
  clubId            String        @map("club_id") @db.Uuid
  startsAt          DateTime      @map("starts_at")
  endsAt            DateTime?     @map("ends_at")
  mode              MeetingMode
  location          String?
  videoLink         String?       @map("video_link")
  agenda            String?
  currentBookId     String?       @map("current_book_id") @db.Uuid
  createdAt         DateTime      @default(now()) @map("created_at")
  updatedAt         DateTime      @updatedAt @map("updated_at")
  club              Club          @relation(fields: [clubId], references: [id], onDelete: Cascade)
  currentBook       Book?         @relation("MeetingCurrentBook", fields: [currentBookId], references: [id])
  polls             Poll[]
  readingPlansEnd   ReadingPlan[] @relation("ReadingPlanEnd")
  readingPlansStart ReadingPlan[] @relation("ReadingPlanStart")
  rsvps             Rsvp[]

  @@map("meetings")
}

model ReadingPlan {
  id             String   @id @default(uuid()) @db.Uuid
  clubId         String   @map("club_id") @db.Uuid
  bookId         String   @map("book_id") @db.Uuid
  startMeetingId String   @map("start_meeting_id") @db.Uuid
  endMeetingId   String   @map("end_meeting_id") @db.Uuid
  createdAt      DateTime @default(now()) @map("created_at")
  book           Book     @relation(fields: [bookId], references: [id])
  club           Club     @relation(fields: [clubId], references: [id], onDelete: Cascade)
  endMeeting     Meeting  @relation("ReadingPlanEnd", fields: [endMeetingId], references: [id])
  startMeeting   Meeting  @relation("ReadingPlanStart", fields: [startMeetingId], references: [id])

  @@map("reading_plans")
}

model Poll {
  id        String       @id @default(uuid()) @db.Uuid
  clubId    String       @map("club_id") @db.Uuid
  meetingId String?      @map("meeting_id") @db.Uuid
  createdBy String       @map("created_by") @db.Uuid
  status    PollStatus   @default(OPEN)
  method    PollMethod   @default(APPROVAL)
  createdAt DateTime     @default(now()) @map("created_at")
  updatedAt DateTime     @updatedAt @map("updated_at")
  options   PollOption[]
  club      Club         @relation(fields: [clubId], references: [id])
  creator   User         @relation("PollCreator", fields: [createdBy], references: [id])
  meeting   Meeting?     @relation(fields: [meetingId], references: [id])

  @@map("polls")
}

model PollOption {
  id             String @id @default(uuid()) @db.Uuid
  pollId         String @map("poll_id") @db.Uuid
  bookId         String @map("book_id") @db.Uuid
  proposerUserId String @map("proposer_user_id") @db.Uuid
  book           Book   @relation(fields: [bookId], references: [id])
  poll           Poll   @relation(fields: [pollId], references: [id], onDelete: Cascade)
  proposer       User   @relation("PollProposer", fields: [proposerUserId], references: [id])
  votes          Vote[]

  @@unique([pollId, bookId])
  @@map("poll_options")
}

model Vote {
  id           String     @id @default(uuid()) @db.Uuid
  pollOptionId String     @map("poll_option_id") @db.Uuid
  voterUserId  String     @map("voter_user_id") @db.Uuid
  approved     Boolean?
  rank         Int?       @db.SmallInt
  pollOption   PollOption @relation(fields: [pollOptionId], references: [id])
  voter        User       @relation(fields: [voterUserId], references: [id])

  @@unique([pollOptionId, voterUserId])
  @@map("votes")
}

model Rsvp {
  id        String     @id @default(uuid()) @db.Uuid
  meetingId String     @map("meeting_id") @db.Uuid
  userId    String     @map("user_id") @db.Uuid
  status    RsvpStatus
  meeting   Meeting    @relation(fields: [meetingId], references: [id])
  user      User       @relation(fields: [userId], references: [id])

  @@unique([meetingId, userId])
  @@map("rsvps")
}

enum ShelfType {
  TBR
  READ
  DNF
  READING
  CUSTOM
}

enum MemberRole {
  OWNER
  ADMIN
  MEMBER
}

enum MemberStatus {
  ACTIVE
  PENDING
  BANNED
}

enum MeetingMode {
  IN_PERSON
  VIRTUAL
}

enum PollStatus {
  OPEN
  CLOSED
}

enum PollMethod {
  APPROVAL
  RCV
}

enum RsvpStatus {
  GOING
  MAYBE
  NO
}
